{"ast":null,"code":"export default function formatHeaders(headers, ignore = '') {\n  if (!headers || headers.length <= 0) return;\n\n  if (Array.isArray(headers)) {\n    const formattedHeaders = [];\n    headers.forEach(header => {\n      if (!ignore.includes(header)) {\n        const firstInitial = header[0].toUpperCase();\n        const sample = header.slice(1);\n        const match = sample.match(/[A-Z]/g);\n\n        if (match) {\n          let formatted = sample.split('');\n          const indices = [];\n          formatted.forEach((letter, idx) => {\n            if (match.includes(letter)) indices.push(idx);\n          });\n\n          if (indices.length > 0) {\n            let counter = 0;\n            indices.forEach(index => {\n              formatted.splice(index + counter, 0, ' ');\n              counter++;\n            });\n          }\n\n          formatted = formatted.join('');\n          formatted = firstInitial + formatted;\n          formattedHeaders.push(formatted);\n        } else {\n          header = firstInitial + sample;\n          formattedHeaders.push(header);\n        }\n      }\n    });\n    return formattedHeaders.length <= 0 ? null : formattedHeaders;\n  } else {\n    // The headers argument is a single string, not an array.\n    let formattedHeader,\n        headerArray = headers.split(' ');\n    let sample = headerArray[headerArray.length - 1];\n    const firstInitial = sample[0].toUpperCase();\n    sample = sample.slice(1);\n    const match = sample.match(/[A-Z]/g);\n\n    if (match) {\n      let formatted = sample.split('');\n      const indices = [];\n      formatted.forEach((letter, idx) => {\n        if (match.includes(letter)) indices.push(idx);\n      });\n\n      if (indices.length > 0) {\n        let counter = 0;\n        indices.forEach(index => {\n          if (index > 0) {\n            formatted.splice(index + counter, 0, ' ');\n            counter++;\n          }\n        });\n      }\n\n      formatted = formatted.join('');\n      formatted = firstInitial + formatted;\n      headerArray[headerArray.length - 1] = formatted;\n      formattedHeader = headerArray.join(' ');\n    } else {\n      headerArray[headerArray.length - 1] = firstInitial + sample;\n      formattedHeader = headerArray.join(' ');\n    }\n\n    return formattedHeader;\n  }\n}","map":{"version":3,"sources":["/Users/rhead/Coding/campswim/dashboard/dashboard-ncompass/src/hooks/format-headers.js"],"names":["formatHeaders","headers","ignore","length","Array","isArray","formattedHeaders","forEach","header","includes","firstInitial","toUpperCase","sample","slice","match","formatted","split","indices","letter","idx","push","counter","index","splice","join","formattedHeader","headerArray"],"mappings":"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","sourcesContent":["export default function formatHeaders(headers, ignore = '') {\n  if (!headers || headers.length <= 0) return;\n  \n  if (Array.isArray(headers)) {\n    const formattedHeaders = [];\n    headers.forEach(header => {    \n      if (!ignore.includes(header)) {\n        const firstInitial = header[0].toUpperCase();\n        const sample = header.slice(1);\n        const match = sample.match(/[A-Z]/g);\n        \n        if (match) {\n          let formatted = sample.split('');        \n          const indices = [];\n          \n          formatted.forEach((letter, idx) => {\n            if (match.includes(letter)) indices.push(idx);\n          });\n  \n          if (indices.length > 0) {\n            let counter = 0;\n  \n            indices.forEach(index => {\n              formatted.splice(index + counter, 0, ' ');\n              counter++;\n            })\n          }\n  \n          formatted = formatted.join('');\n          formatted = firstInitial + formatted;\n          formattedHeaders.push(formatted);\n        } else {\n          header = firstInitial + sample;\n          formattedHeaders.push(header);\n        }\n      }\n    });\n\n    return formattedHeaders.length <= 0 ? null : formattedHeaders;\n  } else { // The headers argument is a single string, not an array.\n    let formattedHeader, headerArray = headers.split(' ');\n    let sample = headerArray[headerArray.length - 1];\n    const firstInitial = sample[0].toUpperCase();\n    sample = sample.slice(1);\n    const match = sample.match(/[A-Z]/g);\n    \n    if (match) {\n      let formatted = sample.split('');\n      const indices = [];\n      \n      formatted.forEach((letter, idx) => {\n        if (match.includes(letter)) indices.push(idx);\n      });\n\n      if (indices.length > 0) {\n        let counter = 0;\n\n        indices.forEach(index => {\n          if (index > 0) {\n            formatted.splice(index + counter, 0, ' ');\n            counter++;\n          }\n        });\n      }\n\n      formatted = formatted.join('');\n      formatted = firstInitial + formatted;\n      headerArray[headerArray.length - 1] = formatted;\n      formattedHeader = headerArray.join(' ');\n    } else {\n      headerArray[headerArray.length - 1] = firstInitial + sample;\n      formattedHeader = headerArray.join(' ');\n    }\n\n    return formattedHeader;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}