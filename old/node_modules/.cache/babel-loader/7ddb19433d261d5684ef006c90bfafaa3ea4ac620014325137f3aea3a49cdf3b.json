{"ast":null,"code":"export default function formatHeaders(headers, ignore = '') {\n  if (!headers || headers.length <= 0) return;\n  if (Array.isArray(headers)) {\n    const formattedHeaders = [];\n    headers.forEach(header => {\n      if (!ignore.includes(header)) {\n        const firstInitial = header[0].toUpperCase();\n        const sample = header.slice(1);\n        const match = sample.match(/[A-Z]/g);\n        if (match) {\n          let formatted = sample.split('');\n          const indices = [];\n          formatted.forEach((letter, idx) => {\n            if (match.includes(letter)) indices.push(idx);\n          });\n          if (indices.length > 0) {\n            let counter = 0;\n            indices.forEach(index => {\n              formatted.splice(index + counter, 0, ' ');\n              counter++;\n            });\n          }\n          formatted = formatted.join('');\n          formatted = firstInitial + formatted;\n          formattedHeaders.push(formatted);\n        } else {\n          header = firstInitial + sample;\n          formattedHeaders.push(header);\n        }\n      }\n    });\n    return formattedHeaders.length <= 0 ? null : formattedHeaders;\n  } else {\n    // The headers argument is a single string, not an array.\n    let formattedHeader,\n      headerArray = headers.split(' ');\n    let sample = headerArray[headerArray.length - 1];\n    const firstInitial = sample[0].toUpperCase();\n    sample = sample.slice(1);\n    const match = sample.match(/[A-Z]/g);\n    const allCapitalized = headers.match(/[A-Z]/g);\n\n    // If the whole header is capitalized, just return it as is.\n    if (allCapitalized && allCapitalized.length === headers.length) return headers;\n    if (match) {\n      let formatted = sample.split('');\n      const indices = [];\n      formatted.forEach((letter, idx) => {\n        if (match.includes(letter)) indices.push(idx);\n      });\n      if (indices.length > 0) {\n        let counter = 0;\n        indices.forEach(index => {\n          if (index > 0) {\n            formatted.splice(index + counter, 0, ' ');\n            counter++;\n          }\n        });\n      }\n      formatted = formatted.join('');\n      formatted = firstInitial + formatted;\n      headerArray[headerArray.length - 1] = formatted;\n      formattedHeader = headerArray.join(' ');\n    } else {\n      headerArray[headerArray.length - 1] = firstInitial + sample;\n      formattedHeader = headerArray.join(' ');\n    }\n    return formattedHeader;\n  }\n}","map":{"version":3,"names":["formatHeaders","headers","ignore","length","Array","isArray","formattedHeaders","forEach","header","includes","firstInitial","toUpperCase","sample","slice","match","formatted","split","indices","letter","idx","push","counter","index","splice","join","formattedHeader","headerArray","allCapitalized"],"sources":["/Users/rhead/Coding/campswim/dashboard/dashboard-ncompass/src/hooks/format-headers.js"],"sourcesContent":["export default function formatHeaders(headers, ignore = '') {\n  if (!headers || headers.length <= 0) return;\n  \n  if (Array.isArray(headers)) {\n    const formattedHeaders = [];\n    headers.forEach(header => {    \n      if (!ignore.includes(header)) {\n        const firstInitial = header[0].toUpperCase();\n        const sample = header.slice(1);\n        const match = sample.match(/[A-Z]/g);\n        \n        if (match) {\n          let formatted = sample.split('');        \n          const indices = [];\n          \n          formatted.forEach((letter, idx) => {\n            if (match.includes(letter)) indices.push(idx);\n          });\n  \n          if (indices.length > 0) {\n            let counter = 0;\n  \n            indices.forEach(index => {\n              formatted.splice(index + counter, 0, ' ');\n              counter++;\n            })\n          }\n  \n          formatted = formatted.join('');\n          formatted = firstInitial + formatted;\n          formattedHeaders.push(formatted);\n        } else {\n          header = firstInitial + sample;\n          formattedHeaders.push(header);\n        }\n      }\n    });\n\n    return formattedHeaders.length <= 0 ? null : formattedHeaders;\n  } else { // The headers argument is a single string, not an array.\n    let formattedHeader, headerArray = headers.split(' ');\n    let sample = headerArray[headerArray.length - 1];\n    const firstInitial = sample[0].toUpperCase();\n    sample = sample.slice(1);\n    const match = sample.match(/[A-Z]/g);\n    const allCapitalized = headers.match(/[A-Z]/g);\n\n    // If the whole header is capitalized, just return it as is.\n    if (allCapitalized && allCapitalized.length === headers.length) return headers;\n\n    if (match) {\n      let formatted = sample.split('');\n      const indices = [];\n      \n      formatted.forEach((letter, idx) => {\n        if (match.includes(letter)) indices.push(idx);\n      });\n\n      if (indices.length > 0) {\n        let counter = 0;\n\n        indices.forEach(index => {\n          if (index > 0) {\n            formatted.splice(index + counter, 0, ' ');\n            counter++;\n          }\n        });\n      }\n\n      formatted = formatted.join('');\n      formatted = firstInitial + formatted;\n      headerArray[headerArray.length - 1] = formatted;\n      formattedHeader = headerArray.join(' ');\n    } else {\n      headerArray[headerArray.length - 1] = firstInitial + sample;\n      formattedHeader = headerArray.join(' ');\n    }\n\n    return formattedHeader;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}