{"ast":null,"code":"import merge from '../merge';\nimport getThemeValue, { propToStyleFunction } from '../getThemeValue';\nimport { handleBreakpoints, createEmptyBreakpointObject, removeUnusedBreakpoints } from '../breakpoints';\nfunction objectsHaveSameKeys(...objects) {\n  const allKeys = objects.reduce((keys, object) => keys.concat(Object.keys(object)), []);\n  const union = new Set(allKeys);\n  return objects.every(object => union.size === Object.keys(object).length);\n}\nfunction callIfFn(maybeFn, arg) {\n  return typeof maybeFn === 'function' ? maybeFn(arg) : maybeFn;\n}\nfunction styleFunctionSx(props) {\n  const {\n    sx,\n    theme = {}\n  } = props || {};\n  if (!sx) {\n    return null; // emotion & styled-components will neglect null\n  }\n  /*\n   * Receive `sxInput` as object or callback\n   * and then recursively check keys & values to create media query object styles.\n   * (the result will be used in `styled`)\n   */\n\n  function traverse(sxInput) {\n    let sxObject = sxInput;\n    if (typeof sxInput === 'function') {\n      sxObject = sxInput(theme);\n    } else if (typeof sxInput !== 'object') {\n      // value\n      return sxInput;\n    }\n    const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);\n    const breakpointsKeys = Object.keys(emptyBreakpoints);\n    let css = emptyBreakpoints;\n    Object.keys(sxObject).forEach(styleKey => {\n      const value = callIfFn(sxObject[styleKey], theme);\n      if (typeof value === 'object') {\n        if (propToStyleFunction[styleKey]) {\n          css = merge(css, getThemeValue(styleKey, value, theme));\n        } else {\n          const breakpointsValues = handleBreakpoints({\n            theme\n          }, value, x => ({\n            [styleKey]: x\n          }));\n          if (objectsHaveSameKeys(breakpointsValues, value)) {\n            css[styleKey] = styleFunctionSx({\n              sx: value,\n              theme\n            });\n          } else {\n            css = merge(css, breakpointsValues);\n          }\n        }\n      } else {\n        css = merge(css, getThemeValue(styleKey, value, theme));\n      }\n    });\n    return removeUnusedBreakpoints(breakpointsKeys, css);\n  }\n  return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);\n}\nstyleFunctionSx.filterProps = ['sx'];\nexport default styleFunctionSx;","map":{"version":3,"names":["merge","getThemeValue","propToStyleFunction","handleBreakpoints","createEmptyBreakpointObject","removeUnusedBreakpoints","objectsHaveSameKeys","objects","allKeys","reduce","keys","object","concat","Object","union","Set","every","size","length","callIfFn","maybeFn","arg","styleFunctionSx","props","sx","theme","traverse","sxInput","sxObject","emptyBreakpoints","breakpoints","breakpointsKeys","css","forEach","styleKey","value","breakpointsValues","x","Array","isArray","map","filterProps"],"sources":["/Users/rhead/Coding/campswim/dashboard/dashboard-ncompass/node_modules/@mui/system/esm/styleFunctionSx/styleFunctionSx.js"],"sourcesContent":["import merge from '../merge';\nimport getThemeValue, { propToStyleFunction } from '../getThemeValue';\nimport { handleBreakpoints, createEmptyBreakpointObject, removeUnusedBreakpoints } from '../breakpoints';\n\nfunction objectsHaveSameKeys(...objects) {\n  const allKeys = objects.reduce((keys, object) => keys.concat(Object.keys(object)), []);\n  const union = new Set(allKeys);\n  return objects.every(object => union.size === Object.keys(object).length);\n}\n\nfunction callIfFn(maybeFn, arg) {\n  return typeof maybeFn === 'function' ? maybeFn(arg) : maybeFn;\n}\n\nfunction styleFunctionSx(props) {\n  const {\n    sx,\n    theme = {}\n  } = props || {};\n\n  if (!sx) {\n    return null; // emotion & styled-components will neglect null\n  }\n  /*\n   * Receive `sxInput` as object or callback\n   * and then recursively check keys & values to create media query object styles.\n   * (the result will be used in `styled`)\n   */\n\n\n  function traverse(sxInput) {\n    let sxObject = sxInput;\n\n    if (typeof sxInput === 'function') {\n      sxObject = sxInput(theme);\n    } else if (typeof sxInput !== 'object') {\n      // value\n      return sxInput;\n    }\n\n    const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);\n    const breakpointsKeys = Object.keys(emptyBreakpoints);\n    let css = emptyBreakpoints;\n    Object.keys(sxObject).forEach(styleKey => {\n      const value = callIfFn(sxObject[styleKey], theme);\n\n      if (typeof value === 'object') {\n        if (propToStyleFunction[styleKey]) {\n          css = merge(css, getThemeValue(styleKey, value, theme));\n        } else {\n          const breakpointsValues = handleBreakpoints({\n            theme\n          }, value, x => ({\n            [styleKey]: x\n          }));\n\n          if (objectsHaveSameKeys(breakpointsValues, value)) {\n            css[styleKey] = styleFunctionSx({\n              sx: value,\n              theme\n            });\n          } else {\n            css = merge(css, breakpointsValues);\n          }\n        }\n      } else {\n        css = merge(css, getThemeValue(styleKey, value, theme));\n      }\n    });\n    return removeUnusedBreakpoints(breakpointsKeys, css);\n  }\n\n  return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);\n}\n\nstyleFunctionSx.filterProps = ['sx'];\nexport default styleFunctionSx;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}